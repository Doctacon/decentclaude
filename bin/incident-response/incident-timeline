#!/usr/bin/env python3
"""
incident-timeline - Build and manage incident timelines

Usage:
  incident-timeline add <incident_id> <event> [options]
  incident-timeline rebuild <incident_id> [options]
  incident-timeline show <incident_id> [options]
  incident-timeline auto-detect [options]

Commands:
  add          Add an event to incident timeline
  rebuild      Rebuild timeline from git/logs
  show         Display incident timeline
  auto-detect  Auto-detect timeline events from git and logs

Options:
  --timestamp=<time>     Event timestamp (ISO format, default: now)
  --source=<source>      Source of event: manual, git, log, alert
  --since=<time>         Start time for auto-detection
  --format=<format>      Output format: text, markdown, mermaid (default: text)
  --git-repo=<path>      Git repository path (default: .)
  --help, -h             Show this help message

Examples:
  # Add event to timeline
  incident-timeline add INC-001 "Started investigation"

  # Rebuild timeline from git commits
  incident-timeline rebuild INC-001 --since="2024-01-15 10:00"

  # Show timeline
  incident-timeline show INC-001

  # Auto-detect events
  incident-timeline auto-detect --since="1 hour ago"
"""

import sys
import os
import json
import subprocess
from datetime import datetime, timedelta
from pathlib import Path
import argparse
import re


class Colors:
    """ANSI color codes for terminal output"""
    RED = '\033[0;31m'
    GREEN = '\033[0;32m'
    YELLOW = '\033[1;33m'
    BLUE = '\033[0;34m'
    CYAN = '\033[0;36m'
    MAGENTA = '\033[0;35m'
    RESET = '\033[0m'
    BOLD = '\033[1m'


class TimelineEvent:
    """Represents a timeline event"""

    def __init__(self, timestamp: str, event: str, source: str = 'manual', metadata: dict = None):
        self.timestamp = timestamp
        self.event = event
        self.source = source
        self.metadata = metadata or {}

    def to_dict(self) -> dict:
        return {
            'timestamp': self.timestamp,
            'event': self.event,
            'source': self.source,
            'metadata': self.metadata
        }

    @classmethod
    def from_dict(cls, data: dict):
        return cls(
            timestamp=data['timestamp'],
            event=data['event'],
            source=data.get('source', 'manual'),
            metadata=data.get('metadata', {})
        )


class TimelineBuilder:
    """Builds incident timelines from various sources"""

    def __init__(self, reports_dir: str = './incidents'):
        self.reports_dir = Path(reports_dir)

    def _load_incident(self, incident_id: str) -> dict:
        """Load incident data"""
        path = self.reports_dir / f"{incident_id}.json"

        if not path.exists():
            raise FileNotFoundError(f"Incident {incident_id} not found")

        with open(path, 'r') as f:
            return json.load(f)

    def _save_incident(self, incident_id: str, data: dict):
        """Save incident data"""
        path = self.reports_dir / f"{incident_id}.json"

        with open(path, 'w') as f:
            json.dump(data, f, indent=2)

    def add_event(self, incident_id: str, event: str, timestamp: str = None, source: str = 'manual'):
        """Add an event to the timeline"""
        incident = self._load_incident(incident_id)

        if timestamp is None:
            timestamp = datetime.utcnow().isoformat()

        timeline_event = TimelineEvent(timestamp, event, source)
        incident['timeline'].append(timeline_event.to_dict())
        incident['updated_at'] = datetime.utcnow().isoformat()

        # Sort timeline by timestamp
        incident['timeline'].sort(key=lambda x: x['timestamp'])

        self._save_incident(incident_id, incident)

        return timeline_event

    def get_git_commits(self, since: str, repo_path: str = '.') -> list:
        """Get git commits since a given time"""
        try:
            # Convert since to git format
            if 'ago' in since:
                git_since = since
            else:
                git_since = since

            cmd = ['git', '-C', repo_path, 'log',
                   f'--since={git_since}',
                   '--pretty=format:%ai|||%h|||%s|||%an']

            result = subprocess.run(cmd, capture_output=True, text=True, check=True)

            commits = []
            for line in result.stdout.strip().split('\n'):
                if not line:
                    continue

                parts = line.split('|||')
                if len(parts) == 4:
                    timestamp_str, commit_hash, message, author = parts

                    # Parse timestamp
                    timestamp = datetime.fromisoformat(timestamp_str.replace(' ', 'T', 1).split()[0])

                    commits.append({
                        'timestamp': timestamp.isoformat(),
                        'event': f"Git commit: {message} ({commit_hash})",
                        'source': 'git',
                        'metadata': {
                            'commit_hash': commit_hash,
                            'author': author,
                            'message': message
                        }
                    })

            return commits

        except subprocess.CalledProcessError:
            return []

    def auto_detect_events(self, since: str, repo_path: str = '.') -> list:
        """Auto-detect timeline events from various sources"""
        events = []

        # Get git commits
        git_events = self.get_git_commits(since, repo_path)
        events.extend(git_events)

        # Sort by timestamp
        events.sort(key=lambda x: x['timestamp'])

        return events

    def rebuild_timeline(self, incident_id: str, since: str, repo_path: str = '.'):
        """Rebuild timeline from git and logs"""
        incident = self._load_incident(incident_id)

        # Get auto-detected events
        detected_events = self.auto_detect_events(since, repo_path)

        # Keep manual events
        manual_events = [e for e in incident.get('timeline', []) if e.get('source') == 'manual']

        # Combine and sort
        all_events = manual_events + detected_events
        all_events.sort(key=lambda x: x['timestamp'])

        incident['timeline'] = all_events
        incident['updated_at'] = datetime.utcnow().isoformat()

        self._save_incident(incident_id, incident)

        return all_events

    def get_timeline(self, incident_id: str) -> list:
        """Get incident timeline"""
        incident = self._load_incident(incident_id)
        return [TimelineEvent.from_dict(e) for e in incident.get('timeline', [])]


def format_timeline_text(events: list) -> str:
    """Format timeline as text"""
    if not events:
        return f"{Colors.YELLOW}No timeline events{Colors.RESET}"

    output = f"\n{Colors.CYAN}{Colors.BOLD}Incident Timeline ({len(events)} events){Colors.RESET}\n\n"

    for event in events:
        source_icon = {
            'manual': 'ðŸ“',
            'git': 'ðŸ“¦',
            'log': 'ðŸ“„',
            'alert': 'ðŸš¨'
        }.get(event.source, 'â€¢')

        timestamp = event.timestamp.split('T')
        date = timestamp[0]
        time = timestamp[1].split('.')[0] if len(timestamp) > 1 else ''

        output += f"{source_icon} {Colors.BLUE}{date} {time}{Colors.RESET}\n"
        output += f"   {event.event}\n\n"

    return output


def format_timeline_markdown(events: list) -> str:
    """Format timeline as Markdown"""
    if not events:
        return "_No timeline events_"

    md = "## Timeline\n\n"

    for event in events:
        source_icon = {
            'manual': 'ðŸ“',
            'git': 'ðŸ“¦',
            'log': 'ðŸ“„',
            'alert': 'ðŸš¨'
        }.get(event.source, 'â€¢')

        md += f"- **{event.timestamp}** {source_icon} {event.event}\n"

    return md


def format_timeline_mermaid(events: list) -> str:
    """Format timeline as Mermaid diagram"""
    if not events:
        return "```mermaid\ntimeline\n    No events\n```"

    diagram = "```mermaid\ntimeline\n"
    diagram += "    title Incident Timeline\n"

    current_date = None
    for event in events:
        timestamp = event.timestamp.split('T')[0]

        if timestamp != current_date:
            diagram += f"    section {timestamp}\n"
            current_date = timestamp

        # Simplify event text for mermaid
        event_text = event.event.replace('"', "'")[:50]
        diagram += f"        {event_text}\n"

    diagram += "```"

    return diagram


def cmd_add(args):
    """Add event to timeline"""
    builder = TimelineBuilder(args.dir)

    event = builder.add_event(
        args.incident_id,
        args.event,
        timestamp=args.timestamp,
        source=args.source or 'manual'
    )

    print(f"{Colors.GREEN}Added event to {args.incident_id}{Colors.RESET}")
    print(f"Timestamp: {event.timestamp}")
    print(f"Event: {event.event}")


def cmd_rebuild(args):
    """Rebuild timeline from git/logs"""
    builder = TimelineBuilder(args.dir)

    events = builder.rebuild_timeline(
        args.incident_id,
        args.since,
        repo_path=args.git_repo
    )

    print(f"{Colors.GREEN}Rebuilt timeline for {args.incident_id}{Colors.RESET}")
    print(f"Total events: {len(events)}")


def cmd_show(args):
    """Show incident timeline"""
    builder = TimelineBuilder(args.dir)

    try:
        events = builder.get_timeline(args.incident_id)

        if args.format == 'markdown':
            print(format_timeline_markdown(events))
        elif args.format == 'mermaid':
            print(format_timeline_mermaid(events))
        else:
            print(format_timeline_text(events))

    except FileNotFoundError as e:
        print(f"{Colors.RED}Error: {str(e)}{Colors.RESET}", file=sys.stderr)
        sys.exit(1)


def cmd_auto_detect(args):
    """Auto-detect timeline events"""
    builder = TimelineBuilder(args.dir)

    events = builder.auto_detect_events(
        args.since,
        repo_path=args.git_repo
    )

    print(f"{Colors.CYAN}Auto-detected {len(events)} events{Colors.RESET}\n")

    for event in events:
        timestamp = event['timestamp']
        source = event['source']
        text = event['event']

        source_icon = {'git': 'ðŸ“¦', 'log': 'ðŸ“„', 'alert': 'ðŸš¨'}.get(source, 'â€¢')

        print(f"{source_icon} {Colors.BLUE}{timestamp}{Colors.RESET}")
        print(f"   {text}\n")


def main():
    parser = argparse.ArgumentParser(
        description="Build and manage incident timelines",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=__doc__
    )

    subparsers = parser.add_subparsers(dest='command', help='Commands')

    # Common arguments
    common = argparse.ArgumentParser(add_help=False)
    common.add_argument('--dir', default='./incidents')

    # Add command
    add_parser = subparsers.add_parser('add', parents=[common], help='Add event to timeline')
    add_parser.add_argument('incident_id')
    add_parser.add_argument('event')
    add_parser.add_argument('--timestamp')
    add_parser.add_argument('--source', choices=['manual', 'git', 'log', 'alert'])

    # Rebuild command
    rebuild_parser = subparsers.add_parser('rebuild', parents=[common], help='Rebuild timeline from git/logs')
    rebuild_parser.add_argument('incident_id')
    rebuild_parser.add_argument('--since', required=True)
    rebuild_parser.add_argument('--git-repo', default='.')

    # Show command
    show_parser = subparsers.add_parser('show', parents=[common], help='Show incident timeline')
    show_parser.add_argument('incident_id')
    show_parser.add_argument('--format', choices=['text', 'markdown', 'mermaid'], default='text')

    # Auto-detect command
    detect_parser = subparsers.add_parser('auto-detect', parents=[common], help='Auto-detect timeline events')
    detect_parser.add_argument('--since', required=True)
    detect_parser.add_argument('--git-repo', default='.')

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        sys.exit(1)

    # Execute command
    if args.command == 'add':
        cmd_add(args)
    elif args.command == 'rebuild':
        cmd_rebuild(args)
    elif args.command == 'show':
        cmd_show(args)
    elif args.command == 'auto-detect':
        cmd_auto_detect(args)


if __name__ == "__main__":
    main()
