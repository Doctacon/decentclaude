#!/usr/bin/env python3
"""
sf-schema-diff - Compare schemas of two Snowflake tables

Usage:
  sf-schema-diff <table_a> <table_b> [options]

Arguments:
  table_a    First table ID (format: database.schema.table)
  table_b    Second table ID (format: database.schema.table)

Options:
  --format=<format>  Output format: text, json (default: text)
  --help, -h         Show this help message

Examples:
  sf-schema-diff mydb.public.table_v1 mydb.public.table_v2
  sf-schema-diff dev_db.staging.users prod_db.public.users --format=json
"""

import sys
import json
import argparse
from typing import Dict, List, Set, Tuple
import snowflake.connector
import os


class Colors:
    """ANSI color codes for terminal output"""
    RED = '\033[0;31m'
    GREEN = '\033[0;32m'
    YELLOW = '\033[1;33m'
    BLUE = '\033[0;34m'
    CYAN = '\033[0;36m'
    RESET = '\033[0m'
    BOLD = '\033[1m'


def get_snowflake_connection():
    """
    Create a Snowflake connection using environment variables.

    Required environment variables:
        SNOWFLAKE_ACCOUNT: Snowflake account identifier
        SNOWFLAKE_USER: Username
        SNOWFLAKE_PASSWORD: Password (or use SNOWFLAKE_AUTHENTICATOR for SSO)
        SNOWFLAKE_WAREHOUSE: Warehouse name (optional)
        SNOWFLAKE_ROLE: Role name (optional)
    """
    try:
        conn_params = {
            'account': os.environ.get('SNOWFLAKE_ACCOUNT'),
            'user': os.environ.get('SNOWFLAKE_USER'),
        }

        # Authentication
        if os.environ.get('SNOWFLAKE_AUTHENTICATOR'):
            conn_params['authenticator'] = os.environ['SNOWFLAKE_AUTHENTICATOR']
        else:
            conn_params['password'] = os.environ.get('SNOWFLAKE_PASSWORD')

        # Optional parameters
        if os.environ.get('SNOWFLAKE_WAREHOUSE'):
            conn_params['warehouse'] = os.environ['SNOWFLAKE_WAREHOUSE']
        if os.environ.get('SNOWFLAKE_ROLE'):
            conn_params['role'] = os.environ['SNOWFLAKE_ROLE']

        return snowflake.connector.connect(**conn_params)
    except Exception as e:
        print(f"{Colors.RED}Error connecting to Snowflake: {str(e)}{Colors.RESET}", file=sys.stderr)
        print(f"{Colors.YELLOW}Make sure SNOWFLAKE_ACCOUNT, SNOWFLAKE_USER, and SNOWFLAKE_PASSWORD are set{Colors.RESET}", file=sys.stderr)
        sys.exit(1)


def parse_table_id(table_id: str) -> Tuple[str, str, str]:
    """
    Parse a fully qualified table ID into database, schema, and table name.

    Args:
        table_id: Full table ID (database.schema.table)

    Returns:
        Tuple of (database, schema, table)
    """
    parts = table_id.split('.')
    if len(parts) != 3:
        print(f"{Colors.RED}Invalid table ID format. Expected: database.schema.table{Colors.RESET}", file=sys.stderr)
        sys.exit(1)
    return parts[0], parts[1], parts[2]


def get_table_schema(conn, table_id: str) -> Dict[str, str]:
    """
    Get the schema of a Snowflake table as a dictionary.

    Args:
        conn: Snowflake connection
        table_id: Full table ID (database.schema.table)

    Returns:
        Dictionary mapping field names to field types
    """
    database, schema_name, table_name = parse_table_id(table_id)

    query = """
    SELECT
        COLUMN_NAME,
        DATA_TYPE,
        IS_NULLABLE,
        NUMERIC_PRECISION,
        NUMERIC_SCALE,
        CHARACTER_MAXIMUM_LENGTH
    FROM INFORMATION_SCHEMA.COLUMNS
    WHERE TABLE_CATALOG = %s
      AND TABLE_SCHEMA = %s
      AND TABLE_NAME = %s
    ORDER BY ORDINAL_POSITION
    """

    try:
        cursor = conn.cursor()
        cursor.execute(query, (database.upper(), schema_name.upper(), table_name.upper()))
        rows = cursor.fetchall()
        cursor.close()

        if not rows:
            print(f"{Colors.RED}Table not found: {table_id}{Colors.RESET}", file=sys.stderr)
            sys.exit(1)

        schema = {}
        for row in rows:
            column_name, data_type, is_nullable, precision, scale, max_length = row

            # Build type string with details
            type_str = data_type
            if data_type in ('NUMBER', 'DECIMAL', 'NUMERIC') and precision is not None:
                if scale is not None and scale > 0:
                    type_str = f"{data_type}({precision},{scale})"
                else:
                    type_str = f"{data_type}({precision})"
            elif data_type in ('VARCHAR', 'CHAR', 'STRING', 'TEXT') and max_length is not None:
                type_str = f"{data_type}({max_length})"

            # Add nullability if NOT NULL
            if is_nullable == 'NO':
                type_str += " (NOT NULL)"

            schema[column_name] = type_str

        return schema
    except Exception as e:
        print(f"{Colors.RED}Error fetching schema for {table_id}: {str(e)}{Colors.RESET}", file=sys.stderr)
        sys.exit(1)


def compare_schemas(schema_a: Dict[str, str], schema_b: Dict[str, str]) -> Tuple[Set[str], Set[str], Dict[str, Tuple[str, str]]]:
    """
    Compare two schemas and identify differences.

    Args:
        schema_a: Schema of first table
        schema_b: Schema of second table

    Returns:
        Tuple of (fields only in A, fields only in B, fields with type changes)
    """
    keys_a = set(schema_a.keys())
    keys_b = set(schema_b.keys())

    only_in_a = keys_a - keys_b
    only_in_b = keys_b - keys_a

    type_changes = {}
    for key in keys_a & keys_b:
        if schema_a[key] != schema_b[key]:
            type_changes[key] = (schema_a[key], schema_b[key])

    return only_in_a, only_in_b, type_changes


def print_text_report(table_a: str, table_b: str, only_in_a: Set[str], only_in_b: Set[str],
                     type_changes: Dict[str, Tuple[str, str]], schema_a: Dict[str, str],
                     schema_b: Dict[str, str]):
    """Print a formatted text report of schema differences"""

    print(f"\n{Colors.CYAN}{Colors.BOLD}Schema Comparison{Colors.RESET}")
    print(f"{Colors.BLUE}Table A:{Colors.RESET} {table_a}")
    print(f"{Colors.BLUE}Table B:{Colors.RESET} {table_b}")
    print("=" * 80)

    # Fields only in A
    if only_in_a:
        print(f"\n{Colors.RED}{Colors.BOLD}Fields only in Table A ({len(only_in_a)}):{Colors.RESET}")
        for field in sorted(only_in_a):
            print(f"  {Colors.RED}−{Colors.RESET} {field}: {schema_a[field]}")

    # Fields only in B
    if only_in_b:
        print(f"\n{Colors.GREEN}{Colors.BOLD}Fields only in Table B ({len(only_in_b)}):{Colors.RESET}")
        for field in sorted(only_in_b):
            print(f"  {Colors.GREEN}+{Colors.RESET} {field}: {schema_b[field]}")

    # Type changes
    if type_changes:
        print(f"\n{Colors.YELLOW}{Colors.BOLD}Fields with type changes ({len(type_changes)}):{Colors.RESET}")
        for field, (type_a, type_b) in sorted(type_changes.items()):
            print(f"  {Colors.YELLOW}~{Colors.RESET} {field}:")
            print(f"    {Colors.RED}A:{Colors.RESET} {type_a}")
            print(f"    {Colors.GREEN}B:{Colors.RESET} {type_b}")

    # Summary
    print(f"\n{Colors.CYAN}{Colors.BOLD}Summary{Colors.RESET}")
    if not only_in_a and not only_in_b and not type_changes:
        print(f"{Colors.GREEN}✓ Schemas are identical{Colors.RESET}")
    else:
        print(f"  Fields only in A: {len(only_in_a)}")
        print(f"  Fields only in B: {len(only_in_b)}")
        print(f"  Type changes: {len(type_changes)}")
        print(f"  {Colors.YELLOW}⚠ Schemas differ{Colors.RESET}")
    print("=" * 80)


def print_json_report(table_a: str, table_b: str, only_in_a: Set[str], only_in_b: Set[str],
                     type_changes: Dict[str, Tuple[str, str]], schema_a: Dict[str, str],
                     schema_b: Dict[str, str]):
    """Print a JSON report of schema differences"""

    report = {
        "table_a": table_a,
        "table_b": table_b,
        "only_in_a": [{"field": field, "type": schema_a[field]} for field in sorted(only_in_a)],
        "only_in_b": [{"field": field, "type": schema_b[field]} for field in sorted(only_in_b)],
        "type_changes": [
            {
                "field": field,
                "type_a": type_a,
                "type_b": type_b
            }
            for field, (type_a, type_b) in sorted(type_changes.items())
        ],
        "identical": not only_in_a and not only_in_b and not type_changes,
        "summary": {
            "fields_only_in_a": len(only_in_a),
            "fields_only_in_b": len(only_in_b),
            "type_changes": len(type_changes)
        }
    }

    print(json.dumps(report, indent=2))


def main():
    parser = argparse.ArgumentParser(
        description="Compare schemas of two Snowflake tables",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=__doc__
    )
    parser.add_argument("table_a", help="First table ID (database.schema.table)")
    parser.add_argument("table_b", help="Second table ID (database.schema.table)")
    parser.add_argument("--format", choices=["text", "json"], default="text",
                       help="Output format (default: text)")

    args = parser.parse_args()

    # Initialize Snowflake connection
    conn = get_snowflake_connection()

    # Get schemas
    schema_a = get_table_schema(conn, args.table_a)
    schema_b = get_table_schema(conn, args.table_b)

    # Compare schemas
    only_in_a, only_in_b, type_changes = compare_schemas(schema_a, schema_b)

    # Print report
    if args.format == "json":
        print_json_report(args.table_a, args.table_b, only_in_a, only_in_b, type_changes, schema_a, schema_b)
    else:
        print_text_report(args.table_a, args.table_b, only_in_a, only_in_b, type_changes, schema_a, schema_b)

    # Close connection
    conn.close()

    # Exit with status code
    if only_in_a or only_in_b or type_changes:
        sys.exit(1)
    else:
        sys.exit(0)


if __name__ == "__main__":
    main()
