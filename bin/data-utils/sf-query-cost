#!/usr/bin/env python3
"""
sf-query-cost - Estimate Snowflake query cost before execution

Usage:
  sf-query-cost <query> [options]
  sf-query-cost --file=<sql_file> [options]

Arguments:
  query      SQL query to estimate (use quotes for multi-line)

Options:
  --file=<path>      Read query from SQL file
  --format=<format>  Output format: text, json (default: text)
  --warehouse=<wh>   Warehouse size (X-Small to 4X-Large, default: from env)
  --help, -h         Show this help message

Examples:
  sf-query-cost "SELECT * FROM mydb.public.table WHERE date = '2024-01-01'"
  sf-query-cost --file=query.sql
  sf-query-cost --file=query.sql --warehouse=LARGE --format=json

Notes:
  Cost estimation is based on query profile statistics and warehouse size.
  Actual costs may vary based on query complexity and data volume.
"""

import sys
import json
import argparse
from pathlib import Path
import snowflake.connector
import os
import re


class Colors:
    """ANSI color codes for terminal output"""
    RED = '\033[0;31m'
    GREEN = '\033[0;32m'
    YELLOW = '\033[1;33m'
    BLUE = '\033[0;34m'
    CYAN = '\033[0;36m'
    RESET = '\033[0m'
    BOLD = '\033[1m'


# Snowflake warehouse credit rates per hour
WAREHOUSE_CREDITS = {
    'X-SMALL': 1,
    'SMALL': 2,
    'MEDIUM': 4,
    'LARGE': 8,
    'X-LARGE': 16,
    'XXL': 32,
    '2X-LARGE': 32,
    'XXXL': 64,
    '3X-LARGE': 64,
    'XXXXL': 128,
    '4X-LARGE': 128,
}

# Average credit cost (varies by region and edition)
# Standard edition in US regions typically $2-3 per credit
DEFAULT_CREDIT_COST_USD = 2.50


def get_snowflake_connection():
    """Create a Snowflake connection using environment variables."""
    try:
        conn_params = {
            'account': os.environ.get('SNOWFLAKE_ACCOUNT'),
            'user': os.environ.get('SNOWFLAKE_USER'),
        }

        # Authentication
        if os.environ.get('SNOWFLAKE_AUTHENTICATOR'):
            conn_params['authenticator'] = os.environ['SNOWFLAKE_AUTHENTICATOR']
        else:
            conn_params['password'] = os.environ.get('SNOWFLAKE_PASSWORD')

        # Optional parameters
        if os.environ.get('SNOWFLAKE_WAREHOUSE'):
            conn_params['warehouse'] = os.environ['SNOWFLAKE_WAREHOUSE']
        if os.environ.get('SNOWFLAKE_ROLE'):
            conn_params['role'] = os.environ['SNOWFLAKE_ROLE']

        return snowflake.connector.connect(**conn_params)
    except Exception as e:
        print(f"{Colors.RED}Error connecting to Snowflake: {str(e)}{Colors.RESET}", file=sys.stderr)
        print(f"{Colors.YELLOW}Make sure SNOWFLAKE_ACCOUNT, SNOWFLAKE_USER, and SNOWFLAKE_PASSWORD are set{Colors.RESET}", file=sys.stderr)
        sys.exit(1)


def estimate_query_cost(conn, query: str, warehouse_size: str = None) -> dict:
    """
    Estimate the cost of a Snowflake query using EXPLAIN.

    Args:
        conn: Snowflake connection
        query: SQL query to estimate
        warehouse_size: Warehouse size (if not provided, uses current warehouse)

    Returns:
        Dictionary with cost estimation details
    """
    try:
        cursor = conn.cursor()

        # Get current warehouse if not specified
        if not warehouse_size:
            cursor.execute("SELECT CURRENT_WAREHOUSE()")
            current_warehouse = cursor.fetchone()[0]
            if current_warehouse:
                cursor.execute(f"SHOW WAREHOUSES LIKE '{current_warehouse}'")
                wh_info = cursor.fetchone()
                if wh_info:
                    warehouse_size = wh_info[3]  # Size column
            else:
                warehouse_size = 'MEDIUM'  # Default if no warehouse set

        warehouse_size = warehouse_size.upper()
        if warehouse_size not in WAREHOUSE_CREDITS:
            print(f"{Colors.YELLOW}Warning: Unknown warehouse size '{warehouse_size}', using MEDIUM{Colors.RESET}", file=sys.stderr)
            warehouse_size = 'MEDIUM'

        # Execute EXPLAIN to get query plan
        cursor.execute(f"EXPLAIN {query}")
        explain_output = cursor.fetchall()

        # Parse explain output for complexity indicators
        explain_text = '\n'.join([row[0] for row in explain_output])

        # Estimate based on explain plan complexity
        # This is a simplified estimation model
        complexity_score = 1.0

        # Increase for joins
        join_count = len(re.findall(r'JOIN', explain_text, re.IGNORECASE))
        complexity_score += join_count * 0.3

        # Increase for aggregations
        agg_count = len(re.findall(r'Aggregate|GroupBy', explain_text, re.IGNORECASE))
        complexity_score += agg_count * 0.2

        # Increase for sorts
        sort_count = len(re.findall(r'Sort', explain_text, re.IGNORECASE))
        complexity_score += sort_count * 0.15

        # Increase for window functions
        window_count = len(re.findall(r'WindowFunction', explain_text, re.IGNORECASE))
        complexity_score += window_count * 0.25

        # Estimate execution time in seconds (very rough)
        # Simple queries: 1-5 seconds, complex: 10-60 seconds
        estimated_seconds = min(60, max(1, complexity_score * 5))

        # Calculate credits
        credits_per_hour = WAREHOUSE_CREDITS[warehouse_size]
        credits_per_second = credits_per_hour / 3600
        estimated_credits = credits_per_second * estimated_seconds

        # Snowflake bills in 1-second increments with 60-second minimum
        billed_seconds = max(60, estimated_seconds)
        billed_credits = credits_per_second * billed_seconds

        # Calculate cost
        estimated_cost_usd = billed_credits * DEFAULT_CREDIT_COST_USD

        cursor.close()

        return {
            "warehouse_size": warehouse_size,
            "credits_per_hour": credits_per_hour,
            "estimated_seconds": estimated_seconds,
            "billed_seconds": billed_seconds,
            "estimated_credits": estimated_credits,
            "billed_credits": billed_credits,
            "estimated_cost_usd": estimated_cost_usd,
            "credit_cost_usd": DEFAULT_CREDIT_COST_USD,
            "complexity_score": complexity_score,
            "query": query,
            "explain_plan": explain_text
        }

    except Exception as e:
        print(f"{Colors.RED}Error estimating query cost: {str(e)}{Colors.RESET}", file=sys.stderr)
        sys.exit(1)


def format_bytes(bytes_value: int) -> str:
    """Format bytes into human-readable string"""
    for unit in ['B', 'KB', 'MB', 'GB', 'TB', 'PB']:
        if bytes_value < 1024.0:
            return f"{bytes_value:.2f} {unit}"
        bytes_value /= 1024.0
    return f"{bytes_value:.2f} EB"


def get_cost_category(cost_usd: float) -> tuple:
    """Get cost category and color based on estimated cost"""
    if cost_usd < 0.001:
        return "Very Low", Colors.GREEN
    elif cost_usd < 0.01:
        return "Low", Colors.GREEN
    elif cost_usd < 0.10:
        return "Moderate", Colors.YELLOW
    elif cost_usd < 1.00:
        return "High", Colors.YELLOW
    else:
        return "Very High", Colors.RED


def print_text_report(result: dict):
    """Print a formatted text report of cost estimation"""

    cost_category, cost_color = get_cost_category(result['estimated_cost_usd'])

    print(f"\n{Colors.CYAN}{Colors.BOLD}Snowflake Query Cost Estimation{Colors.RESET}")
    print("=" * 80)

    print(f"\n{Colors.BOLD}Warehouse:{Colors.RESET}")
    print(f"  Size:              {result['warehouse_size']}")
    print(f"  Credits/hour:      {result['credits_per_hour']}")

    print(f"\n{Colors.BOLD}Execution Estimate:{Colors.RESET}")
    print(f"  Estimated time:    {result['estimated_seconds']:.1f} seconds")
    print(f"  Billed time:       {result['billed_seconds']:.1f} seconds (60s minimum)")
    print(f"  Complexity score:  {result['complexity_score']:.2f}")

    print(f"\n{Colors.BOLD}Credit Estimate:{Colors.RESET}")
    print(f"  Estimated credits: {result['estimated_credits']:.6f}")
    print(f"  Billed credits:    {result['billed_credits']:.6f}")

    print(f"\n{Colors.BOLD}Cost Estimate:{Colors.RESET}")
    print(f"  Credit price:      ${result['credit_cost_usd']:.2f} USD/credit")
    print(f"  Total cost:        {cost_color}${result['estimated_cost_usd']:.6f} USD{Colors.RESET}")
    print(f"  Category:          {cost_color}{cost_category}{Colors.RESET}")

    print(f"\n{Colors.BOLD}Notes:{Colors.RESET}")
    print("  • This is a rough estimate based on query complexity")
    print("  • Actual cost depends on data volume and query execution")
    print("  • Snowflake bills in 1-second increments with 60-second minimum")
    print("  • Credit costs vary by region and Snowflake edition")
    print(f"  • Using ${result['credit_cost_usd']:.2f}/credit (typical Standard edition pricing)")

    print(f"\n{Colors.BOLD}Query Preview:{Colors.RESET}")
    query_lines = result['query'].strip().split('\n')
    preview_lines = query_lines[:5]
    for line in preview_lines:
        print(f"  {line}")
    if len(query_lines) > 5:
        print(f"  ... ({len(query_lines) - 5} more lines)")

    print("\n" + "=" * 80)


def print_json_report(result: dict):
    """Print a JSON report of cost estimation"""
    output = {
        "warehouse_size": result['warehouse_size'],
        "credits_per_hour": result['credits_per_hour'],
        "estimated_seconds": round(result['estimated_seconds'], 2),
        "billed_seconds": round(result['billed_seconds'], 2),
        "estimated_credits": round(result['estimated_credits'], 6),
        "billed_credits": round(result['billed_credits'], 6),
        "estimated_cost_usd": round(result['estimated_cost_usd'], 6),
        "credit_cost_usd": result['credit_cost_usd'],
        "complexity_score": round(result['complexity_score'], 2),
        "category": get_cost_category(result['estimated_cost_usd'])[0].lower().replace(' ', '_')
    }
    print(json.dumps(output, indent=2))


def main():
    parser = argparse.ArgumentParser(
        description="Estimate Snowflake query cost before execution",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=__doc__
    )
    parser.add_argument("query", nargs="?", help="SQL query to estimate")
    parser.add_argument("--file", help="Read query from SQL file")
    parser.add_argument("--warehouse", help="Warehouse size (X-Small to 4X-Large)")
    parser.add_argument("--format", choices=["text", "json"], default="text",
                       help="Output format (default: text)")

    args = parser.parse_args()

    # Get query from argument or file
    if args.file:
        try:
            query = Path(args.file).read_text()
        except Exception as e:
            print(f"{Colors.RED}Error reading file {args.file}: {str(e)}{Colors.RESET}", file=sys.stderr)
            sys.exit(1)
    elif args.query:
        query = args.query
    else:
        parser.print_help()
        sys.exit(1)

    # Initialize Snowflake connection
    conn = get_snowflake_connection()

    # Estimate query cost
    result = estimate_query_cost(conn, query, args.warehouse)

    # Print report
    if args.format == "json":
        print_json_report(result)
    else:
        print_text_report(result)

    # Close connection
    conn.close()


if __name__ == "__main__":
    main()
