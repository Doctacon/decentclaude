#!/usr/bin/env python3
"""
ai-query - Natural language to SQL query builder powered by Claude

Usage:
  ai-query <description> [options]
  ai-query --interactive [options]
  ai-query --explain <sql> [options]

Arguments:
  description    Natural language description of the query

Options:
  --interactive, -i    Interactive mode for query refinement
  --explain           Explain an existing SQL query in natural language
  --validate          Validate generated SQL against BigQuery (default: true)
  --no-validate       Skip SQL validation
  --format=<format>   Output format: text, json, sql (default: text)
  --context=<tables>  Comma-separated list of table IDs for context
  --help, -h          Show this help message

Examples:
  ai-query "show me top 10 customers by revenue this year"
  ai-query "count orders by status for each month" --context=project.dataset.orders
  ai-query --interactive
  ai-query --explain "SELECT COUNT(*) FROM users WHERE active = true"
"""

import sys
import json
import os
import argparse
from typing import List, Dict, Optional
from pathlib import Path


class Colors:
    """ANSI color codes for terminal output"""
    RED = '\033[0;31m'
    GREEN = '\033[0;32m'
    YELLOW = '\033[1;33m'
    BLUE = '\033[0;34m'
    CYAN = '\033[0;36m'
    MAGENTA = '\033[0;35m'
    RESET = '\033[0m'
    BOLD = '\033[1m'


class AIQueryBuilder:
    """Natural language to SQL query builder using Claude API"""

    def __init__(self):
        self.api_key = os.environ.get('ANTHROPIC_API_KEY')
        if not self.api_key:
            raise ValueError(
                "ANTHROPIC_API_KEY environment variable not set. "
                "Get your API key from https://console.anthropic.com/"
            )

        try:
            import anthropic
            self.client = anthropic.Anthropic(api_key=self.api_key)
        except ImportError:
            raise ImportError(
                "anthropic package not installed. "
                "Install with: pip install anthropic"
            )

    def generate_sql(
        self,
        description: str,
        context_tables: Optional[List[str]] = None,
        schema_info: Optional[Dict] = None
    ) -> Dict[str, str]:
        """
        Generate SQL query from natural language description.

        Args:
            description: Natural language description of the query
            context_tables: Optional list of table IDs to provide context
            schema_info: Optional schema information for context tables

        Returns:
            Dictionary with 'sql' and 'explanation' keys
        """
        # Build context from schema info if provided
        context = ""
        if schema_info:
            context = "\n\nAvailable Tables and Schemas:\n"
            for table_id, schema in schema_info.items():
                context += f"\n{table_id}:\n"
                for field in schema:
                    context += f"  - {field['name']}: {field['type']}\n"
        elif context_tables:
            context = f"\n\nContext Tables: {', '.join(context_tables)}"

        prompt = f"""Convert this natural language description into a BigQuery SQL query.

Description: {description}{context}

Provide:
1. The SQL query (use BigQuery Standard SQL syntax)
2. A brief explanation of what the query does

Format your response as:
SQL:
```sql
[your query here]
```

EXPLANATION:
[your explanation here]

Important:
- Use BigQuery Standard SQL syntax
- Include appropriate JOINs if multiple tables are involved
- Use window functions when needed for analytics
- Add appropriate WHERE clauses for filtering
- Use date/time functions like DATE(), TIMESTAMP() for date operations
- Include comments in the SQL for complex logic
"""

        try:
            message = self.client.messages.create(
                model="claude-sonnet-4-5@20250929",
                max_tokens=2048,
                messages=[
                    {"role": "user", "content": prompt}
                ]
            )

            response_text = message.content[0].text

            # Parse response to extract SQL and explanation
            sql_query = ""
            explanation = ""

            # Extract SQL from code block
            if "```sql" in response_text:
                sql_start = response_text.find("```sql") + 6
                sql_end = response_text.find("```", sql_start)
                sql_query = response_text[sql_start:sql_end].strip()

            # Extract explanation
            if "EXPLANATION:" in response_text:
                explanation = response_text.split("EXPLANATION:")[1].strip()
            elif "Explanation:" in response_text:
                explanation = response_text.split("Explanation:")[1].strip()

            # Fallback: if we couldn't parse, use the whole response
            if not sql_query:
                # Try to find any SQL-like content
                lines = response_text.split('\n')
                sql_lines = [line for line in lines if any(
                    keyword in line.upper()
                    for keyword in ['SELECT', 'FROM', 'WHERE', 'JOIN', 'GROUP BY', 'ORDER BY']
                )]
                sql_query = '\n'.join(sql_lines) if sql_lines else response_text

            return {
                "sql": sql_query,
                "explanation": explanation,
                "raw_response": response_text
            }

        except Exception as e:
            raise Exception(f"Error generating SQL: {str(e)}")

    def explain_sql(self, sql_query: str) -> str:
        """
        Explain an existing SQL query in natural language.

        Args:
            sql_query: SQL query to explain

        Returns:
            Natural language explanation of the query
        """
        prompt = f"""Explain this BigQuery SQL query in clear, natural language.

SQL Query:
```sql
{sql_query}
```

Provide a detailed explanation that covers:
1. What data is being retrieved
2. What tables are involved
3. What filters/conditions are applied
4. Any joins or aggregations
5. The expected result

Write the explanation in a clear, structured way that a non-technical person can understand.
"""

        try:
            message = self.client.messages.create(
                model="claude-sonnet-4-5@20250929",
                max_tokens=1024,
                messages=[
                    {"role": "user", "content": prompt}
                ]
            )

            return message.content[0].text

        except Exception as e:
            raise Exception(f"Error explaining SQL: {str(e)}")


def validate_sql_with_bigquery(sql_query: str) -> Dict[str, any]:
    """
    Validate SQL query using BigQuery dry run.

    Args:
        sql_query: SQL query to validate

    Returns:
        Dictionary with validation results
    """
    try:
        from google.cloud import bigquery
        client = bigquery.Client()

        # Configure dry run job
        job_config = bigquery.QueryJobConfig(dry_run=True, use_query_cache=False)

        # Run dry run query
        query_job = client.query(sql_query, job_config=job_config)

        # Get bytes to process
        bytes_processed = query_job.total_bytes_processed
        gb_processed = bytes_processed / (1024 ** 3)

        return {
            "valid": True,
            "bytes_processed": bytes_processed,
            "gb_processed": round(gb_processed, 4),
            "error": None
        }

    except Exception as e:
        return {
            "valid": False,
            "bytes_processed": 0,
            "gb_processed": 0,
            "error": str(e)
        }


def get_table_schema(table_id: str) -> Optional[List[Dict]]:
    """
    Get schema information for a BigQuery table.

    Args:
        table_id: Full table ID (project.dataset.table)

    Returns:
        List of field dictionaries with 'name' and 'type' keys
    """
    try:
        from google.cloud import bigquery
        client = bigquery.Client()
        table = client.get_table(table_id)

        return [
            {"name": field.name, "type": field.field_type}
            for field in table.schema
        ]
    except Exception:
        return None


def print_text_report(result: Dict, validation: Optional[Dict] = None):
    """Print a formatted text report of query generation"""

    print(f"\n{Colors.CYAN}{Colors.BOLD}AI Query Builder{Colors.RESET}")
    print("=" * 80)

    # SQL Query
    print(f"\n{Colors.BOLD}Generated SQL:{Colors.RESET}")
    print(f"{Colors.GREEN}{result['sql']}{Colors.RESET}")

    # Explanation
    if result.get('explanation'):
        print(f"\n{Colors.BOLD}Explanation:{Colors.RESET}")
        print(f"{result['explanation']}")

    # Validation results
    if validation:
        print(f"\n{Colors.BOLD}Validation:{Colors.RESET}")
        if validation['valid']:
            print(f"  {Colors.GREEN}✓ Query is valid{Colors.RESET}")
            print(f"  Estimated data to process: {validation['gb_processed']:.4f} GB")
        else:
            print(f"  {Colors.RED}✗ Query validation failed{Colors.RESET}")
            print(f"  Error: {validation['error']}")

    print("\n" + "=" * 80)


def print_json_report(result: Dict, validation: Optional[Dict] = None):
    """Print a JSON report of query generation"""
    output = {
        "sql": result['sql'],
        "explanation": result.get('explanation', ''),
    }

    if validation:
        output['validation'] = {
            "valid": validation['valid'],
            "gb_processed": validation['gb_processed'],
            "error": validation['error']
        }

    print(json.dumps(output, indent=2))


def interactive_mode(builder: AIQueryBuilder, validate: bool = True):
    """
    Interactive mode for query refinement.

    Args:
        builder: AIQueryBuilder instance
        validate: Whether to validate queries with BigQuery
    """
    print(f"\n{Colors.CYAN}{Colors.BOLD}AI Query Builder - Interactive Mode{Colors.RESET}")
    print("Enter your query description (or 'quit' to exit)")
    print("Use 'refine: <changes>' to refine the last query")
    print("Use 'explain' to explain the last query")
    print("=" * 80)

    last_result = None
    context_tables = []

    while True:
        try:
            user_input = input(f"\n{Colors.BLUE}>{Colors.RESET} ").strip()

            if not user_input:
                continue

            if user_input.lower() in ['quit', 'exit', 'q']:
                print("\nGoodbye!")
                break

            # Handle context setting
            if user_input.startswith('context:'):
                context_tables = [t.strip() for t in user_input[8:].split(',')]
                print(f"{Colors.GREEN}Context tables set: {', '.join(context_tables)}{Colors.RESET}")
                continue

            # Handle refinement
            if user_input.lower().startswith('refine:'):
                if not last_result:
                    print(f"{Colors.RED}No previous query to refine{Colors.RESET}")
                    continue

                refinement = user_input[7:].strip()
                description = f"Modify this SQL query: {last_result['sql']}\n\nChanges: {refinement}"
            elif user_input.lower() == 'explain':
                if not last_result:
                    print(f"{Colors.RED}No previous query to explain{Colors.RESET}")
                    continue

                explanation = builder.explain_sql(last_result['sql'])
                print(f"\n{Colors.BOLD}Explanation:{Colors.RESET}")
                print(explanation)
                continue
            else:
                description = user_input

            # Get table schemas if context tables are provided
            schema_info = {}
            if context_tables:
                for table_id in context_tables:
                    schema = get_table_schema(table_id)
                    if schema:
                        schema_info[table_id] = schema

            # Generate SQL
            print(f"{Colors.YELLOW}Generating SQL...{Colors.RESET}")
            result = builder.generate_sql(
                description,
                context_tables=context_tables if context_tables else None,
                schema_info=schema_info if schema_info else None
            )
            last_result = result

            # Validate if requested
            validation = None
            if validate:
                print(f"{Colors.YELLOW}Validating SQL...{Colors.RESET}")
                validation = validate_sql_with_bigquery(result['sql'])

            # Print result
            print_text_report(result, validation)

        except KeyboardInterrupt:
            print("\n\nGoodbye!")
            break
        except Exception as e:
            print(f"{Colors.RED}Error: {str(e)}{Colors.RESET}")


def main():
    parser = argparse.ArgumentParser(
        description="Natural language to SQL query builder powered by Claude",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=__doc__
    )
    parser.add_argument("description", nargs="?", help="Natural language description of the query")
    parser.add_argument("--interactive", "-i", action="store_true",
                       help="Interactive mode for query refinement")
    parser.add_argument("--explain", help="Explain an existing SQL query")
    parser.add_argument("--validate", dest="validate", action="store_true", default=True,
                       help="Validate generated SQL against BigQuery (default)")
    parser.add_argument("--no-validate", dest="validate", action="store_false",
                       help="Skip SQL validation")
    parser.add_argument("--format", choices=["text", "json", "sql"], default="text",
                       help="Output format (default: text)")
    parser.add_argument("--context", help="Comma-separated list of table IDs for context")

    args = parser.parse_args()

    # Initialize builder
    try:
        builder = AIQueryBuilder()
    except Exception as e:
        print(f"{Colors.RED}Error initializing AI Query Builder: {str(e)}{Colors.RESET}", file=sys.stderr)
        sys.exit(1)

    # Handle interactive mode
    if args.interactive:
        interactive_mode(builder, validate=args.validate)
        return

    # Handle explain mode
    if args.explain:
        try:
            explanation = builder.explain_sql(args.explain)
            print(f"\n{Colors.BOLD}SQL Query Explanation:{Colors.RESET}")
            print(explanation)
            print()
        except Exception as e:
            print(f"{Colors.RED}Error: {str(e)}{Colors.RESET}", file=sys.stderr)
            sys.exit(1)
        return

    # Handle regular query generation
    if not args.description:
        parser.print_help()
        sys.exit(1)

    # Parse context tables
    context_tables = None
    schema_info = None
    if args.context:
        context_tables = [t.strip() for t in args.context.split(',')]

        # Get table schemas
        schema_info = {}
        for table_id in context_tables:
            schema = get_table_schema(table_id)
            if schema:
                schema_info[table_id] = schema

    # Generate SQL
    try:
        result = builder.generate_sql(
            args.description,
            context_tables=context_tables,
            schema_info=schema_info
        )
    except Exception as e:
        print(f"{Colors.RED}Error: {str(e)}{Colors.RESET}", file=sys.stderr)
        sys.exit(1)

    # Validate if requested
    validation = None
    if args.validate:
        validation = validate_sql_with_bigquery(result['sql'])
        if not validation['valid']:
            print(f"{Colors.YELLOW}Warning: Generated SQL failed validation{Colors.RESET}", file=sys.stderr)

    # Print output
    if args.format == "sql":
        print(result['sql'])
    elif args.format == "json":
        print_json_report(result, validation)
    else:
        print_text_report(result, validation)

    # Exit with error if validation failed
    if validation and not validation['valid']:
        sys.exit(1)


if __name__ == "__main__":
    main()
