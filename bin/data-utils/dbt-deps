#!/usr/bin/env python3
"""
dbt-deps - Visualize dbt model dependencies as graph

Usage:
  dbt-deps [options]
  dbt-deps <model_name> [options]

Arguments:
  model_name     Focus on a specific model and its dependencies

Options:
  --manifest=<path>     Path to manifest.json (default: target/manifest.json)
  --format=<format>     Output format: tree, mermaid, dot, json (default: tree)
  --upstream            Show upstream dependencies only (models this depends on)
  --downstream          Show downstream dependencies only (models that depend on this)
  --depth=<n>           Maximum depth to traverse (default: unlimited)
  --help, -h            Show this help message

Examples:
  dbt-deps                                    # Show all model dependencies
  dbt-deps stg_users                          # Show dependencies for stg_users
  dbt-deps stg_users --upstream               # Show what stg_users depends on
  dbt-deps stg_users --downstream             # Show what depends on stg_users
  dbt-deps --format=mermaid > deps.mmd        # Export as Mermaid diagram
  dbt-deps --format=dot | dot -Tpng > deps.png  # Export as PNG
"""

import sys
import json
import argparse
from pathlib import Path
from typing import Dict, Set, List, Optional
from collections import defaultdict


class Colors:
    """ANSI color codes for terminal output"""
    RED = '\033[0;31m'
    GREEN = '\033[0;32m'
    YELLOW = '\033[1;33m'
    BLUE = '\033[0;34m'
    CYAN = '\033[0;36m'
    MAGENTA = '\033[0;35m'
    RESET = '\033[0m'
    BOLD = '\033[1m'
    DIM = '\033[2m'


class DbtDependencyGraph:
    """Parse and visualize dbt model dependencies"""

    def __init__(self, manifest_path: Path):
        self.manifest_path = manifest_path
        self.manifest = self._load_manifest()
        self.models = self._extract_models()
        self.dependencies = self._build_dependency_graph()

    def _load_manifest(self) -> dict:
        """Load and parse manifest.json"""
        try:
            with open(self.manifest_path) as f:
                return json.load(f)
        except FileNotFoundError:
            print(f"{Colors.RED}Error: manifest.json not found at {self.manifest_path}{Colors.RESET}", file=sys.stderr)
            print(f"{Colors.YELLOW}Run 'dbt compile' or 'dbt run' to generate manifest.json{Colors.RESET}", file=sys.stderr)
            sys.exit(1)
        except json.JSONDecodeError as e:
            print(f"{Colors.RED}Error: Invalid JSON in manifest.json: {str(e)}{Colors.RESET}", file=sys.stderr)
            sys.exit(1)

    def _extract_models(self) -> Dict[str, dict]:
        """Extract model information from manifest"""
        models = {}
        for node_id, node in self.manifest.get('nodes', {}).items():
            if node.get('resource_type') == 'model':
                model_name = node.get('name')
                models[model_name] = {
                    'unique_id': node_id,
                    'name': model_name,
                    'schema': node.get('schema'),
                    'database': node.get('database'),
                    'depends_on': node.get('depends_on', {}).get('nodes', []),
                    'description': node.get('description', ''),
                    'materialized': node.get('config', {}).get('materialized', 'view'),
                    'tags': node.get('tags', []),
                    'package_name': node.get('package_name', '')
                }
        return models

    def _build_dependency_graph(self) -> Dict[str, Set[str]]:
        """Build dependency graph: model -> set of models it depends on"""
        graph = defaultdict(set)

        for model_name, model_info in self.models.items():
            for dep_id in model_info['depends_on']:
                # Extract model name from unique_id (e.g., model.project.model_name)
                if dep_id.startswith('model.'):
                    dep_name = dep_id.split('.')[-1]
                    if dep_name in self.models:
                        graph[model_name].add(dep_name)

        return dict(graph)

    def get_upstream_deps(self, model_name: str, max_depth: Optional[int] = None) -> Set[str]:
        """Get all upstream dependencies (models that this model depends on)"""
        if model_name not in self.models:
            return set()

        visited = set()
        to_visit = [(model_name, 0)]

        while to_visit:
            current, depth = to_visit.pop(0)
            if current in visited:
                continue
            if max_depth is not None and depth > max_depth:
                continue

            visited.add(current)

            for dep in self.dependencies.get(current, []):
                if dep not in visited:
                    to_visit.append((dep, depth + 1))

        visited.discard(model_name)  # Remove the starting model
        return visited

    def get_downstream_deps(self, model_name: str, max_depth: Optional[int] = None) -> Set[str]:
        """Get all downstream dependencies (models that depend on this model)"""
        if model_name not in self.models:
            return set()

        # Build reverse dependency graph
        reverse_deps = defaultdict(set)
        for model, deps in self.dependencies.items():
            for dep in deps:
                reverse_deps[dep].add(model)

        visited = set()
        to_visit = [(model_name, 0)]

        while to_visit:
            current, depth = to_visit.pop(0)
            if current in visited:
                continue
            if max_depth is not None and depth > max_depth:
                continue

            visited.add(current)

            for dep in reverse_deps.get(current, []):
                if dep not in visited:
                    to_visit.append((dep, depth + 1))

        visited.discard(model_name)  # Remove the starting model
        return visited

    def format_tree(self, model_name: Optional[str] = None, upstream: bool = False,
                   downstream: bool = False, max_depth: Optional[int] = None) -> str:
        """Format dependencies as a tree"""
        output = []

        if model_name:
            if model_name not in self.models:
                return f"{Colors.RED}Model '{model_name}' not found{Colors.RESET}"

            model_info = self.models[model_name]
            output.append(f"\n{Colors.CYAN}{Colors.BOLD}Model: {model_name}{Colors.RESET}")
            output.append(f"{Colors.DIM}Type: {model_info['materialized']}{Colors.RESET}")

            if model_info['description']:
                output.append(f"{Colors.DIM}Description: {model_info['description'][:80]}{Colors.RESET}")

            if upstream or (not upstream and not downstream):
                output.append(f"\n{Colors.YELLOW}Upstream Dependencies (depends on):{Colors.RESET}")
                upstream_deps = self.get_upstream_deps(model_name, max_depth)
                if upstream_deps:
                    for i, dep in enumerate(sorted(upstream_deps), 1):
                        prefix = "├──" if i < len(upstream_deps) else "└──"
                        output.append(f"  {prefix} {Colors.GREEN}{dep}{Colors.RESET}")
                else:
                    output.append(f"  {Colors.DIM}(no upstream dependencies){Colors.RESET}")

            if downstream or (not upstream and not downstream):
                output.append(f"\n{Colors.YELLOW}Downstream Dependencies (depends on this):{Colors.RESET}")
                downstream_deps = self.get_downstream_deps(model_name, max_depth)
                if downstream_deps:
                    for i, dep in enumerate(sorted(downstream_deps), 1):
                        prefix = "├──" if i < len(downstream_deps) else "└──"
                        output.append(f"  {prefix} {Colors.BLUE}{dep}{Colors.RESET}")
                else:
                    output.append(f"  {Colors.DIM}(no downstream dependencies){Colors.RESET}")

        else:
            output.append(f"\n{Colors.CYAN}{Colors.BOLD}All Model Dependencies{Colors.RESET}")
            output.append(f"{Colors.DIM}Total models: {len(self.models)}{Colors.RESET}\n")

            for model_name in sorted(self.models.keys()):
                deps = self.dependencies.get(model_name, set())
                if deps:
                    output.append(f"{Colors.GREEN}{model_name}{Colors.RESET} depends on:")
                    for i, dep in enumerate(sorted(deps), 1):
                        prefix = "├──" if i < len(deps) else "└──"
                        output.append(f"  {prefix} {dep}")
                else:
                    output.append(f"{Colors.GREEN}{model_name}{Colors.RESET} {Colors.DIM}(no dependencies){Colors.RESET}")

        return "\n".join(output)

    def format_mermaid(self, model_name: Optional[str] = None, upstream: bool = False,
                      downstream: bool = False, max_depth: Optional[int] = None) -> str:
        """Format dependencies as Mermaid diagram"""
        output = ["graph LR"]

        if model_name:
            if model_name not in self.models:
                return f"Error: Model '{model_name}' not found"

            relevant_models = {model_name}

            if upstream or (not upstream and not downstream):
                relevant_models.update(self.get_upstream_deps(model_name, max_depth))

            if downstream or (not upstream and not downstream):
                relevant_models.update(self.get_downstream_deps(model_name, max_depth))

            # Add edges for relevant models
            for model in relevant_models:
                for dep in self.dependencies.get(model, []):
                    if dep in relevant_models:
                        output.append(f"    {dep} --> {model}")

            # Highlight the focus model
            output.append(f"    style {model_name} fill:#ff9,stroke:#333,stroke-width:4px")

        else:
            # Show all dependencies
            for model, deps in self.dependencies.items():
                for dep in deps:
                    output.append(f"    {dep} --> {model}")

        return "\n".join(output)

    def format_dot(self, model_name: Optional[str] = None, upstream: bool = False,
                  downstream: bool = False, max_depth: Optional[int] = None) -> str:
        """Format dependencies as Graphviz DOT format"""
        output = ['digraph dbt_dependencies {', '    rankdir=LR;', '    node [shape=box];']

        if model_name:
            if model_name not in self.models:
                return f"Error: Model '{model_name}' not found"

            relevant_models = {model_name}

            if upstream or (not upstream and not downstream):
                relevant_models.update(self.get_upstream_deps(model_name, max_depth))

            if downstream or (not upstream and not downstream):
                relevant_models.update(self.get_downstream_deps(model_name, max_depth))

            # Add edges for relevant models
            for model in relevant_models:
                for dep in self.dependencies.get(model, []):
                    if dep in relevant_models:
                        output.append(f'    "{dep}" -> "{model}";')

            # Highlight the focus model
            output.append(f'    "{model_name}" [style=filled,fillcolor=yellow];')

        else:
            # Show all dependencies
            for model, deps in self.dependencies.items():
                for dep in deps:
                    output.append(f'    "{dep}" -> "{model}";')

        output.append('}')
        return "\n".join(output)

    def format_json(self, model_name: Optional[str] = None, upstream: bool = False,
                   downstream: bool = False, max_depth: Optional[int] = None) -> str:
        """Format dependencies as JSON"""
        if model_name:
            if model_name not in self.models:
                return json.dumps({"error": f"Model '{model_name}' not found"}, indent=2)

            result = {
                "model": model_name,
                "info": self.models[model_name]
            }

            if upstream or (not upstream and not downstream):
                result["upstream"] = sorted(list(self.get_upstream_deps(model_name, max_depth)))

            if downstream or (not upstream and not downstream):
                result["downstream"] = sorted(list(self.get_downstream_deps(model_name, max_depth)))

            return json.dumps(result, indent=2)

        else:
            result = {
                "total_models": len(self.models),
                "dependencies": {
                    model: sorted(list(deps))
                    for model, deps in self.dependencies.items()
                }
            }
            return json.dumps(result, indent=2)


def main():
    parser = argparse.ArgumentParser(
        description="Visualize dbt model dependencies as graph",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=__doc__
    )
    parser.add_argument("model_name", nargs="?", help="Focus on a specific model")
    parser.add_argument("--manifest", default="target/manifest.json",
                       help="Path to manifest.json (default: target/manifest.json)")
    parser.add_argument("--format", choices=["tree", "mermaid", "dot", "json"], default="tree",
                       help="Output format (default: tree)")
    parser.add_argument("--upstream", action="store_true",
                       help="Show upstream dependencies only")
    parser.add_argument("--downstream", action="store_true",
                       help="Show downstream dependencies only")
    parser.add_argument("--depth", type=int, help="Maximum depth to traverse")

    args = parser.parse_args()

    # Load dependency graph
    graph = DbtDependencyGraph(Path(args.manifest))

    # Generate output
    if args.format == "tree":
        output = graph.format_tree(args.model_name, args.upstream, args.downstream, args.depth)
    elif args.format == "mermaid":
        output = graph.format_mermaid(args.model_name, args.upstream, args.downstream, args.depth)
    elif args.format == "dot":
        output = graph.format_dot(args.model_name, args.upstream, args.downstream, args.depth)
    elif args.format == "json":
        output = graph.format_json(args.model_name, args.upstream, args.downstream, args.depth)

    print(output)


if __name__ == "__main__":
    main()
