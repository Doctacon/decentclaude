#!/usr/bin/env bash
# wt-status - Show status of all worktrees in the Gas Town workspace
#
# Usage: wt-status [options]
#
# Options:
#   --verbose, -v     Show detailed git status for each worktree
#   --dirty-only, -d  Only show worktrees with uncommitted changes
#   --help, -h        Show this help message

set -euo pipefail

# Color codes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
RESET='\033[0m'

# Options
VERBOSE=false
DIRTY_ONLY=false

# Parse arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -v|--verbose)
            VERBOSE=true
            shift
            ;;
        -d|--dirty-only)
            DIRTY_ONLY=true
            shift
            ;;
        -h|--help)
            grep '^#' "$0" | sed 's/^# \?//'
            exit 0
            ;;
        *)
            echo "Unknown option: $1"
            exit 1
            ;;
    esac
done

# Find the bare repo
BARE_REPO=$(git rev-parse --git-common-dir 2>/dev/null || echo "")
if [[ -z "$BARE_REPO" ]]; then
    echo "Error: Not in a git repository"
    exit 1
fi

# Get worktree list
echo -e "${CYAN}Worktree Status${RESET}"
echo "Bare repo: $BARE_REPO"
echo ""

# Parse git worktree list
while IFS= read -r line; do
    # Extract worktree path
    if [[ $line =~ ^worktree[[:space:]]+(.*) ]]; then
        WORKTREE_PATH="${BASH_REMATCH[1]}"

        # Skip bare repos
        if [[ $WORKTREE_PATH == *".repo.git"* ]]; then
            continue
        fi

        # Get branch info
        read -r branch_line
        if [[ $branch_line =~ branch[[:space:]]+refs/heads/(.*) ]]; then
            BRANCH="${BASH_REMATCH[1]}"
        else
            BRANCH="(detached HEAD)"
        fi

        # Check status
        cd "$WORKTREE_PATH" 2>/dev/null || continue

        # Get git status
        STATUS_OUTPUT=$(git status --porcelain 2>/dev/null || echo "")
        if [[ -n "$STATUS_OUTPUT" ]]; then
            UNCOMMITTED_COUNT=$(echo "$STATUS_OUTPUT" | wc -l | tr -d ' ')
        else
            UNCOMMITTED_COUNT=0
        fi

        # Get ahead/behind info (skip if no upstream)
        if git rev-parse @{upstream} >/dev/null 2>&1; then
            AHEAD_BEHIND=$(git rev-list --left-right --count @{upstream}...HEAD 2>/dev/null || echo "0	0")
            BEHIND=$(echo "$AHEAD_BEHIND" | cut -f1)
            AHEAD=$(echo "$AHEAD_BEHIND" | cut -f2)
        else
            BEHIND=0
            AHEAD=0
        fi

        # Determine status color and message
        if [[ $UNCOMMITTED_COUNT -gt 0 ]]; then
            STATUS_COLOR=$RED
            STATUS_MSG="dirty ($UNCOMMITTED_COUNT changes)"
        elif [[ $AHEAD -gt 0 ]] || [[ $BEHIND -gt 0 ]]; then
            STATUS_COLOR=$YELLOW
            STATUS_MSG="out of sync (↑$AHEAD ↓$BEHIND)"
        else
            STATUS_COLOR=$GREEN
            STATUS_MSG="clean"
        fi

        # Skip if dirty-only mode and worktree is clean
        if $DIRTY_ONLY && [[ $UNCOMMITTED_COUNT -eq 0 ]]; then
            continue
        fi

        # Extract worktree name from path
        WORKTREE_NAME=$(basename "$WORKTREE_PATH")

        # Print status
        echo -e "${BLUE}$WORKTREE_NAME${RESET} [$BRANCH] - ${STATUS_COLOR}$STATUS_MSG${RESET}"
        echo "  Path: $WORKTREE_PATH"

        # Show detailed status if verbose
        if $VERBOSE && [[ -n "$STATUS_OUTPUT" ]]; then
            echo "  Changes:"
            echo "$STATUS_OUTPUT" | head -20 | sed 's/^/    /'
            if [[ $(echo "$STATUS_OUTPUT" | wc -l) -gt 20 ]]; then
                echo "    ... ($(( $(echo "$STATUS_OUTPUT" | wc -l) - 20 )) more)"
            fi
        fi

        echo ""
    fi
done < <(git worktree list --porcelain)

echo -e "${CYAN}Summary${RESET}"
TOTAL_WORKTREES=$(git worktree list | grep -v "(bare)" | wc -l)
echo "Total worktrees: $TOTAL_WORKTREES"
